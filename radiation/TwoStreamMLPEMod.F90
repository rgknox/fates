Module TwoStreamMLPEMod

  ! This module holds the routines to calculate two-tream
  ! radiation scattering of vegetation in
  ! "M"ultiple "L"ayers with "P"arellel "E"lements "MLPE"
  !
  ! In summary,
  ! there may numerous canopy layers. In each canopy layer,
  ! plant media for different functional types are grouped
  ! so that they inhabit their own exclusive footprint
  ! within the layer. Within these exclusive functional
  ! columns, there are further sub-layer discretizations,
  ! which are organized by top-down integrated vegetation
  ! area index.
  !
  ! Note that there is a separate allocation and call
  ! sequence for each broad band.  In other words, the
  ! two_stream_type is instantiated for each broad band.
  !
  ! 
  !
  ! Assumptions: band index 1 = visible (vis)
  !                         2 = near infrared (nir)
  !                         3 = thermal (not used at the moment)
  !

  implicit none
  private

  integer, parameter :: r8 = selected_real_kind(12)
  real(r8),parameter :: nearzero = 1.e-20_r8
  logical, parameter :: debug=.true.
  logical, parameter :: use_derivation1 = .true.
  real(r8), parameter :: unset_r8 = 1.e-36_r8
  real(r8), parameter :: unset_int = -999
  integer, parameter :: twostr_vis = 1         ! Named index of visible shortwave radiation
  integer, parameter :: twostr_nir = 2         ! Named index for near infrared shortwave radiation


  ! Allowable error, as a fraction of total incident for total canopy
  ! radiation balance checks

  real(r8), parameter :: rel_err_thresh = 1.e-8_r8

  ! These are the codes for how the upper boundary is specified, normalized or absolute
  integer,public, parameter :: normalized_upper_boundary = 1
  integer,public, parameter :: absolute_upper_boundary   = 2
  

  
  ! These are parameter constants, ie things that are specific to the plant material
  ! and radiation band.  Not all of these need to be used. 2-stream ultimately wants
  ! optical depth, scattering coefficient and backscatter fractions for diffuse and
  ! direct light. So there are various ways to get to these parameters, depending
  ! on the host model's available parameters.  The rho,tau,xl and clumping parameters
  ! are standard elm/clm parameters, and provided as a convenience.


  ! Snow optical parameter constants for visible (index=1) and NIR (index=2)

  real(r8), parameter :: betad_snow(1:2) = (/0.5, 0.5/)   ! Diffuse backscatter fraction    (CLM50 Tech Man)
  real(r8), parameter :: betab_snow(1:2) = (/0.5, 0.5/)   ! Beam backscatter fraction       (CLM50 Tech Man)  
  real(r8), parameter :: om_snow(1:2)    = (/0.8, 0.4/)   ! Scattering coefficient for snow (CLM50 Tech Man)
  !real(r8), parameter :: om_snow(1:2)    = (/0.85, 0.75/) ! Tarboton 95


  ! For air, use a nominal values to prevent div0s
  ! the key is that vai = 0
  
  real(r8), parameter :: k_air = 0.5_r8  
  real(r8), parameter :: om_air  = 0.5_r8
  real(r8), parameter :: beta_air = 0.5_r8
  integer, public, parameter :: air_ft = 0 

  type, public :: rad_params_type

     ! From the parameter file
     real(r8), allocatable :: rhol(:,:)         ! leaf material reflectance:   (band x pft)
     real(r8), allocatable :: rhos(:,:)         ! stem material reflectance:   (band x pft)
     real(r8), allocatable :: taul(:,:)         ! leaf material transmittance: (band x pft)
     real(r8), allocatable :: taus(:,:)         ! stem material transmittance: (band x pft)
     real(r8), allocatable :: xl(:)             ! leaf/stem orientation (pft)
     real(r8), allocatable :: clumping_index(:) ! clumping index 0-1, when
                                                ! leaves stick together (pft)

     ! Derived parameters
     real(r8), allocatable :: phi1(:)       ! intermediate term for kd and kb
     real(r8), allocatable :: phi2(:)       ! intermediate term for kd and kb
     real(r8), allocatable :: kd_leaf(:)    ! Mean optical depth per unit area leaves in diffuse
     real(r8), allocatable :: kd_stem(:)    ! Mean optical depth per unit area stems in diffuse
     real(r8), allocatable :: om_leaf(:,:)  ! Leaf scattering coefficient (band x pft)
     real(r8), allocatable :: om_stem(:,:)  ! Stem scattering coefficient (band x pft)

  end type rad_params_type

  type(rad_params_type),public :: rad_params


  ! Information describing the scattering elements
  ! that is based on "g"eometry, and independent of wavelength

  type scelg_type
     integer  :: pft      ! pft index
     real(r8) :: area     ! m2 col/m2 ground
     real(r8) :: lai      ! m2 of leaf area / m2 col
     real(r8) :: sai      ! m2 of stem area / m2 col
     real(r8) :: Kb       ! Optical depth of beam radiation
     real(r8) :: Kb_leaf  ! Optical depth of just leaves in beam radiation
     real(r8) :: Kd       ! Optical depth of diffuse radiation
  end type scelg_type


  ! Information describing the scattering elemnets that
  ! is dependent on wavelengths, ie "b"ands (this is allocated for each broad band)

  type scelb_type

     ! Terms used in the final solution, also used for decomposing solution
     real(r8) :: Au      ! Compound intercept term
     real(r8) :: Ad      ! Compound intercept term
     real(r8) :: B1u     ! Compound term w/ lambdas
     real(r8) :: B2u     ! Compound term w/ lambdas
     real(r8) :: B1d     ! Compound term w/ lambdas
     real(r8) :: B2d     ! Compound term w/ lambdas
     real(r8) :: lambda1_diff ! Compount term w/ B1d and B1u for diffuse forcing
     real(r8) :: lambda2_diff ! Compound term w/ B2d and B2u for diffuse forcing
     real(r8) :: lambda1_beam ! Compount term w/ B1d and B1u for beam forcing
     real(r8) :: lambda2_beam ! Compound term w/ B2d and B2u for beam forcing
     
     real(r8) :: a       ! Complex term operating on veg area index
     real(r8) :: om      ! scattering coefficient for media as a whole
     real(r8) :: betad   ! backscatter fraction of diffuse radiation for media as a whole
     real(r8) :: betab   ! backscatter fraction of beam radiation for media as a whole
     real(r8) :: Rbeam0  ! Normalized downwelling beam radiation at
                         ! top of the element (relative to downwelling atmospheric beam) [-]

  end type scelb_type


  type band_type

     type(scelb_type), pointer :: scelb(:,:)       ! array of scattering coefficients (layer, column)
                                                   ! can be sparse, will only solve indices up to
     integer                   :: ib               ! band index, should be consistent with rad_params
     real(r8)                  :: Rbeam_atm        ! Downwelling beam radiation from atmosphere [W/m2 ground]
     real(r8)                  :: Rdiff_atm        ! Downwelling diffuse radiation from atmosphere [W/m2 ground]
     real(r8)                  :: albedo_grnd_diff ! Ground albedo diffuse
     real(r8)                  :: albedo_grnd_beam ! Ground albedo direct 

  end type band_type


  ! This type contains the pre-processed scattering coefficients
  ! and routines.  This is the parent type that holds almost everything
  ! in the two-stream solver.
  ! The scelg structure describes the scattering elements, these are values
  ! that need to be defined by the ecosystem model, somewhat of
  ! an input to the solver. Since this is a Perfect Plasticity Approximation
  ! enabled system, we partition the scattering media into "columns" and "layers"
  ! Layers are canopy layers, think understory, mid-story and upper canopy. Columns
  ! are divisions of horizontal space, ie literal columns of space. The current
  ! implementation limits this space to media that has uniform scattering coefficients.
  ! So there could not be different PFTs in the same column, because they would undoubtedly
  ! have different joint scattering coefficients at different height levels in
  ! the column.  Therefore, every column is connected with a PFT.


  type, public :: twostream_type

     type(scelg_type), pointer :: scelg(:,:)    ! array of scattering elements (layer, column)
                                                ! can be sparse, will only solve indices up to
                                                ! n_lyr,n_col(n_lyr)

     type(band_type), pointer  :: band(:)       ! Holds scattering coefficients for each band
                                                ! vis,nir,etc (nothing that emits though, no thermal)

     integer                   :: n_bands       ! number of bands (allocation size of band(:))
     integer                   :: n_lyr         ! number of (vertical) scattering element layers
     integer, allocatable      :: n_col(:)      ! number of (horizontal) scattering element columns per layer
     integer                   :: n_scel        ! total number of scattering elements
     logical                   :: force_prep    ! Some coefficients are only updated
                                                ! when the canopy composition changes, ie
                                                ! changes in leaf, stem or snow structure.
                                                ! If so, this sets to true, signalling that diffuse
                                                ! scattering coefficients should be updated.
                                                ! Otherwise, we only updated zenith dependent
                                                ! parameters on short sub-daily timesteps
     real(r8)                  :: frac_snow     ! Current mean snow-fraction of the canopy
     real(r8)                  :: frac_snow_old ! Previous mean snow-fraction of the canopy

   contains

     procedure :: ZenithPrep     ! Update coefficients as zenith changes
     procedure :: CanopyPrep     ! Update coefficients as canopy changes
     procedure :: Solve          ! Perform the scattering solution
     procedure :: GetNSCel
     procedure :: AllocInitTwoStream
     procedure :: DeallocTwoStream

     procedure :: GetRdUp
     procedure :: GetRdDn
     procedure :: GetRb
     procedure :: GetAbsRad

  end type twostream_type

  public :: ParamPrep
  public :: AllocateRadParams

  character(len=*), parameter, private :: sourcefile = &
       __FILE__

  
contains

  subroutine AllocInitTwoStream(this,band_indices,ncan,ncol)

    class(twostream_type) :: this
    integer               :: band_indices(:)
    integer               :: ncan
    integer               :: ncol

    integer :: nbands
    integer :: ib

    nbands = ubound(band_indices,1)

    allocate(this%n_col(ncan))
    allocate(this%scelg(ncan,ncol))
    allocate(this%band(nbands))

    this%n_col(1:ncan)    = unset_int
    this%n_bands          = nbands
    this%n_lyr            = ncan
    this%frac_snow        = unset_r8
    this%frac_snow_old    = unset_r8

    do ib = 1,nbands

       allocate(this%band(ib)%scelb(ncan,ncol))
       this%band(ib)%albedo_grnd_diff = unset_r8
       this%band(ib)%albedo_grnd_beam = unset_r8
       this%band(ib)%ib = band_indices(ib)

    end do



    return
  end subroutine AllocInitTwoStream

  ! ===============================================================================================

  subroutine DeallocTwoStream(this)

    class(twostream_type) :: this

    integer               :: nbands
    integer               :: ib

    nbands = ubound(this%band,1)

    deallocate(this%scelg)
    deallocate(this%n_col)
    do ib = 1,nbands
       deallocate(this%band(ib)%scelb)
    end do
    deallocate(this%band)

    return
  end subroutine DeallocTwoStream

  ! ===============================================================================================

  subroutine AllocateRadParams(n_pft,n_bands)

    integer,intent(in) :: n_pft
    integer,intent(in) :: n_bands

    ! Include the zeroth pft index for air
    
    allocate(rad_params%rhol(n_bands,n_pft))
    allocate(rad_params%rhos(n_bands,n_pft))
    allocate(rad_params%taul(n_bands,n_pft))
    allocate(rad_params%taus(n_bands,n_pft))
    allocate(rad_params%xl(n_pft))
    allocate(rad_params%clumping_index(n_pft))

    allocate(rad_params%phi1(n_pft))
    allocate(rad_params%phi2(n_pft))
    allocate(rad_params%kd_leaf(n_pft))
    allocate(rad_params%kd_stem(n_pft))
    allocate(rad_params%om_leaf(n_bands,n_pft))
    allocate(rad_params%om_stem(n_bands,n_pft))
        
  end subroutine AllocateRadParams

  ! ================================================================================================

  function GetRdDn(this,ican,icol,ib,vai) result(r_diff_dn)

    class(twostream_type) :: this
    real(r8),intent(in)   :: vai
    integer,intent(in)    :: ican
    integer,intent(in)    :: icol
    integer,intent(in)    :: ib
    real(r8)              :: r_diff_dn

    ! Rdn = Ad e−(Kbv) + Re + λ1 B1d e^(av) + λ2 B2d e^(−av)

    associate(scelb => this%band(ib)%scelb(ican,icol), &
         scelg => this%scelg(ican,icol) )

      r_diff_dn = this%band(ib)%Rbeam_atm*( &
           scelb%Ad*exp(-scelg%Kb*vai) + &
           scelb%B1d*scelb%lambda1_beam*exp(scelb%a*vai) + &
           scelb%B2d*scelb%lambda2_beam*exp(-scelb%a*vai)) + &
           this%band(ib)%Rdiff_atm*( & 
           scelb%B1d*scelb%lambda1_diff*exp(scelb%a*vai) + &
           scelb%B2d*scelb%lambda2_diff*exp(-scelb%a*vai))
      
      
    end associate
  end function GetRdDn

  function GetRdUp(this,ican,icol,ib,vai) result(r_diff_up)

    class(twostream_type) :: this
    real(r8),intent(in)   :: vai
    integer,intent(in)    :: ican
    integer,intent(in)    :: icol
    integer,intent(in)    :: ib
    real(r8)              :: r_diff_up

    ! Rup = Au e−(Kbv) + Re + λ1 B1u e^(av) + λ2 B2u e^(−av)

    associate(scelb => this%band(ib)%scelb(ican,icol), &
         scelg => this%scelg(ican,icol) )

      r_diff_up = this%band(ib)%Rbeam_atm*( &
           scelb%Au*exp(-scelg%Kb*vai) + &
           scelb%B1u*scelb%lambda1_beam*exp(scelb%a*vai) + &
           scelb%B2u*scelb%lambda2_beam*exp(-scelb%a*vai)) + &
           this%band(ib)%Rdiff_atm*( & 
           scelb%B1u*scelb%lambda1_diff*exp(scelb%a*vai) + &
           scelb%B2u*scelb%lambda2_diff*exp(-scelb%a*vai)) 
           
    end associate
  end function GetRdUp

  function GetRb(this,ican,icol,ib,vai) result(r_beam_dn)

    class(twostream_type) :: this
    real(r8),intent(in)   :: vai
    integer,intent(in)    :: ican
    integer,intent(in)    :: icol
    integer,intent(in)    :: ib
    real(r8)              :: r_beam_dn

    r_beam_dn = this%band(ib)%Rbeam_atm * &
         this%band(ib)%scelb(ican,icol)%Rbeam0*exp(-this%scelg(ican,icol)%Kb*vai)

  end function GetRb

  subroutine GetAbsRad(this,ican,icol,ib,vai_top,vai_bot, &
       Rb_abs,Rd_abs,Rd_abs_leaf,Rb_abs_leaf,R_abs_stem,R_abs_snow,leaf_sun_frac)

    ! This routine is used to help decompose radiation scattering
    ! and return the amount of absorbed radiation.  The canopy layer and column
    ! index identify the element of interest. The other arguments are the upper and
    ! lower bounds within the element over which to evaluate absorbed radiation.
    ! The assumption is that the vegetation area index is zero at the top of the
    ! element, and increases going downwards.  As with all assumptions in this
    ! module, the scattering parameters are uniform within the element itself,
    ! which includes an assumption of the leaf/stem proportionality.
    ! ---------------------------------------------------------------------------
    ! Solution for radiative intensity of diffuse up and down at tai=v
    ! Rup = Au e−(Kbv) + Re + λ1 B1u e^(av) + λ2 B2u e^(−av)
    ! Rdn = Ad e−(Kbv) + Re + λ1 B1d e^(av) + λ2 B2d e^(−av)
    ! ---------------------------------------------------------------------------

    ! Arguments
    class(twostream_type) :: this
    integer,intent(in)    :: ican
    integer,intent(in)    :: icol
    integer,  intent(in)  :: ib            ! broad band index
    real(r8), intent(in)  :: vai_top       ! veg area index (from the top of element) to start
    real(r8), intent(in)  :: vai_bot       ! veg area index (from the top of element) to finish
    real(r8), intent(out) :: Rb_abs        ! total absorbed beam radiation [W/m2 ground]
    real(r8), intent(out) :: Rd_abs        ! total absorbed diffuse radiation [W/m2 ground]
    real(r8), intent(out) :: Rb_abs_leaf   ! Absorbed beam radiation from leaves [W/m2 ground]
    real(r8), intent(out) :: Rd_abs_leaf   ! Absorbed diff radiation from leaves [W/m2 ground]
    real(r8), intent(out) :: R_abs_stem    ! Absorbed beam+diff radiation stems  [W/m2 ground]
    real(r8), intent(out) :: R_abs_snow    ! Absorbed beam+diff radiation snow   [W/m2 ground]
    real(r8), intent(out) :: leaf_sun_frac ! Fraction of leaves in the interval exposed
    ! to sunlight

    real(r8)              :: dvai,dlai     ! Amount of VAI and LAI in this interval [m2/m2]
    real(r8)              :: Rd_net        ! Difference in diffuse radiation at upper and lower boundaries [W/m2]
    real(r8)              :: Rb_net        ! Difference in beam radiation at upper and lower boundaries [W/m2]
    real(r8)              :: vai_max       ! total integrated (leaf+stem) area index of the current element
    real(r8)              :: frac_abs_snow ! fraction of radiation absorbed by snow
    real(r8)              :: diff_wt_leaf  ! diffuse absorption weighting for leaves
    real(r8)              :: diff_wt_stem  ! diffuse absorption weighting for stems
    real(r8)              :: beam_wt_leaf  ! beam absorption weighting for leaves
    real(r8)              :: beam_wt_stem  ! beam absorption weighting for stems

    
    associate(scelb => this%band(ib)%scelb(ican,icol), &
         scelg => this%scelg(ican,icol), &
         ft => this%scelg(ican,icol)%pft )

      ! If this is air, trivial solutions
      if(ft==air_ft) then
         Rb_abs        = 0._r8
         Rd_abs        = 0._r8
         Rb_abs_leaf   = 0._r8
         Rd_abs_leaf   = 0._r8
         R_abs_stem    = 0._r8
         R_abs_snow    = 0._r8
         leaf_sun_frac = 0._r8
         return
      end if
      
      ! The total vegetation area index of the element
      vai_max = scelg%lai +  scelg%sai

      dvai = vai_bot - vai_top
      dlai = dvai *  scelg%lai/( scelg%lai+ scelg%sai)

      leaf_sun_frac = max(0.001_r8,min(0.999_r8,scelb%Rbeam0/ &
           (dvai*scelg%Kb/rad_params%clumping_index(ft)) * (exp(-scelg%Kb*vai_top) - exp(-scelg%Kb*vai_bot)) ))
               
      if(debug) then
         if(leaf_sun_frac>1.0_r8 .or. leaf_sun_frac<0._r8) then
            print*,"impossible leaf sun fraction"
            stop
         end if
      end if

      ! We have to disentangle the absorption between leaves and stems, we give them both
      ! a weighting fraction of total absorption of  area*K*(1-om)

      frac_abs_snow = this%frac_snow*(1._r8-om_snow(ib)) / (1._r8-scelb%om)

      diff_wt_leaf =  scelg%lai*(1._r8-rad_params%om_leaf(ib,ft))*rad_params%Kd_leaf(ft)
      diff_wt_stem =  scelg%sai*(1._r8-rad_params%om_stem(ib,ft))*rad_params%Kd_stem(ft)

      beam_wt_leaf =  scelg%lai*(1._r8-rad_params%om_leaf(ib,ft))*scelg%Kb_leaf
      beam_wt_stem =  scelg%sai*(1._r8-rad_params%om_stem(ib,ft))*1._r8

      ! Mean element transmission coefficients adding snow scattering

      if(debug) then
         if( (vai_bot-vai_max)>rel_err_thresh)then
            print*,"During decomposition of the 2-stream radiation solution"
            print*,"A vegetation area index (VAI) was requested in GetAbsRad()"
            print*,"that is larger than the total integrated VAI of the "
            print*,"computation element of interest."
            print*,"vai_max: ",vai_max
            print*,"vai_bot: ",vai_bot
            stop
         end if
         if( (vai_bot-vai_top)<-rel_err_thresh ) then
            print*,"During decomposition of the 2-stream radiation solution"
            print*,"the vegetation area index at the lower position was set"
            print*,"as greater than the value at the upper position."
            print*,"vai_max: ",vai_max
            print*,"vai_bot: ",vai_bot
            stop
         end if
      end if

      ! Amount of absorbed radiation is retrieved by doing an energy
      ! balance on this boundaries over the depth of interest (ie net)
      ! Result is Watts / m2 of the element's area footprint NOT
      ! per m2 of tissue (at least not in this step)

      Rb_net = this%GetRb(ican,icol,ib,vai_top)-this%GetRb(ican,icol,ib,vai_bot)

      Rd_net = (this%GetRdDn(ican,icol,ib,vai_top) - this%GetRdDn(ican,icol,ib,vai_bot)) + &
           (this%GetRdUp(ican,icol,ib,vai_bot) - this%GetRdUp(ican,icol,ib,vai_top))

      ! The net beam radiation includes that which is absorbed, but also,
      ! that which is re-scattered, the re-scattered acts as a source
      ! to the net diffuse balance and adds to the absorbed, and a sink
      ! on the beam absorbed term.

      Rb_abs = Rb_net * (1._r8-this%band(ib)%scelb(ican,icol)%om)
      Rd_abs = Rd_net +  Rb_net * this%band(ib)%scelb(ican,icol)%om


      Rb_abs_leaf = (1._r8-frac_abs_snow)*Rb_abs * beam_wt_leaf / (beam_wt_leaf+beam_wt_stem)
      Rd_abs_leaf = (1._r8-frac_abs_snow)*Rd_abs * diff_wt_leaf / (diff_wt_leaf+diff_wt_stem)

      R_abs_snow = (Rb_abs+Rd_abs)*frac_abs_snow

      R_abs_stem = (1._r8-frac_abs_snow)* &
           (Rb_abs*beam_wt_stem / (beam_wt_leaf+beam_wt_stem) + &
           Rd_abs*diff_wt_stem / (diff_wt_leaf+diff_wt_stem))




    end associate
    return
  end subroutine GetAbsRad

  ! ================================================================================================

  subroutine ParamPrep()

    real(r8) :: avmu   ! average inverse optical depth (see Eq 3.4 CLM50 tech man)
    integer  :: ft
    integer  :: nbands
    integer  :: numpft
    integer  :: ib

    numpft = ubound(rad_params%om_leaf,2)
    nbands = ubound(rad_params%om_leaf,1)
    
    do ft = 1,numpft

       ! The non-band specific parameters here will be re-derived for each
       ! band, which is inefficient, however this is an incredibly cheap
       ! routine to begin with, its only called during initialization, so
       ! just let it go, dont worry about it.

       if(rad_params%xl(ft)<-0.4_r8 .or. rad_params%xl(ft)>0.6_r8) then
          print*,"Leaf orientation factors (xl) should be between -0.4 and 0.6"
          print*,"ft: ",ft,"xl: ",rad_params%xl(ft)
          stop
       end if

       ! There is a singularity of leaf orientation is exactly 0
       ! phi1 = 0.5
       ! phi2 = 0.0
       ! avmu = 1/0  (1 - 0.5/0 * ln(0.5/0.5) ) but the limit approaches 1
       ! a value of 0.0001 does not break numerics and generates an avmu of nearly 1

       if( abs(rad_params%xl(ft)) <0.0001) rad_params%xl(ft)=0.0001_r8
       
       ! There must be protections on xl to prevent div0 and other weirdness
       rad_params%phi1(ft) = 0.5_r8 - 0.633_r8*rad_params%xl(ft) - 0.330_r8*rad_params%xl(ft)*rad_params%xl(ft)
       rad_params%phi2(ft) = 0.877_r8 * (1._r8 - 2._r8*rad_params%phi1(ft)) !0 = horiz leaves, 1 - vert leaves.
       
       avmu = (1._r8/rad_params%phi2(ft))* &
            (1._r8-(rad_params%phi1(ft)/rad_params%phi2(ft))* &
            log((rad_params%phi2(ft)+rad_params%phi1(ft))/rad_params%phi1(ft)))
       
       do ib = 1, nbands
          rad_params%Kd_leaf(ft) = rad_params%clumping_index(ft)/avmu
          rad_params%Kd_stem(ft) = 1._r8  ! Isotropic assumption
          
          rad_params%om_leaf(ib,ft) = rad_params%rhol(ib,ft) + rad_params%taul(ib,ft)
          rad_params%om_stem(ib,ft) = rad_params%rhos(ib,ft) + rad_params%taus(ib,ft)
       end do
       
    end do

    return
  end subroutine ParamPrep

  ! ================================================================================================


  ! ================================================================================================

  subroutine CanopyPrep(this,frac_snow)

    ! Pre-process things that change with canopy-geometry or snow cover
    ! We try to only run this when necessary. For instance we only
    ! run this when the canopy vegetation composition changes, or
    ! when the amount of snow-cover changes.  

    class(twostream_type) :: this

    real(r8)              :: frac_snow   ! The fraction (in terms of vegetation area index)
    ! of vegetation covered with snow

    ! But we check if the snow conditions
    ! change during the high frequency calls
    ! as well.
    integer :: ib     ! The band of interest
    integer :: ican  ! scattering element canopy layer index (top down)
    integer :: icol  ! scattering element column
    real(r8) :: rho  ! element mean material reflectance
    real(r8) :: tau  ! element mean material transmittance
    real(r8) :: vai  ! vegetation area index lai+sai
    real(r8) :: om_veg     ! scattering coefficient for vegetation (no snow)
    real(r8) :: betad_veg  ! diffuse backscatter for vegetation (no snow)
    real(r8) :: betad_om   ! multiplication of diffuse backscatter and reflectance
    real(r8) :: area_check ! Checks to make sure each layer has 100% coverage

    this%frac_snow = frac_snow

    if(.not.this%force_prep) then
       if(abs(this%frac_snow-this%frac_snow_old)<nearzero) then
          this%frac_snow_old = this%frac_snow
          return
       end if
    end if

    this%frac_snow_old = this%frac_snow

    do_can: do ican = 1,this%n_lyr

       area_check = 0._r8
       do_col: do icol = 1,this%n_col(ican)

          associate(lai => this%scelg(ican,icol)%lai, &
               sai => this%scelg(ican,icol)%sai, &
               ft  => this%scelg(ican,icol)%pft, &
               scelg => this%scelg(ican,icol))

            vai = lai + sai

            ! Mean element transmission coefficients w/o snow effects

            if(ft==0) then
               scelg%Kd = k_air
            else
               scelg%Kd =  (lai * rad_params%Kd_leaf(ft) + &
                    sai * rad_params%Kd_stem(ft))/vai
            end if

            area_check = area_check + scelg%area

            do_bands: do ib = 1, this%n_bands

               associate(scelb => this%band(ib)%scelb(ican,icol))

                 if (ft==0) then

                    scelb%om = om_air
                    scelb%betad = beta_air

                 else

                    ! Material reflectance (weighted average of leaf stem and snow)

                    ! Eq. 3.11 and 3.12 ClM5.0 Tech Man
                    om_veg  =  (lai*rad_params%om_leaf(ib,ft) + &
                         sai*rad_params%om_stem(ib,ft))/vai

                    ! Eq. 3.5 ClM5.0 Tech Man
                    scelb%om = this%frac_snow*om_snow(ib) + (1._r8-this%frac_snow)*om_veg

                    ! Diffuse backscatter, taken from G. Bonan's code

                    rho = (lai * rad_params%rhol(ib,ft) + &
                         sai * rad_params%rhos(ib,ft))/vai
                    tau = (lai * rad_params%taul(ib,ft) + &
                         sai * rad_params%taus(ib,ft))/vai

                    ! Eq 3.13 from CLM5.0 Tech Man
                    betad_veg  = 0.5_r8 / scelb%om * &
                         ( scelb%om + (rho-tau) * ((1._r8+rad_params%xl(ft))/2._r8)**2._r8 )

                    ! Eq. 3.6 from CLM5.0 Tech Man
                    betad_om = betad_veg*om_veg*(1._r8-this%frac_snow) + &
                         om_snow(ib)*betad_snow(ib)*this%frac_snow

                    scelb%betad = betad_om / scelb%om
                    
                 end if
               end associate
            end do do_bands
          end associate
       end do do_col

       if(abs(area_check-1._r8)> 0.01_r8*rel_err_thresh  )then
          print*,"Only a partial canopy was specified"
          print*,"Scattering elements must constitute 100% of the ground cover."
          print*,"for open spaces, create an air element with the respective area."
          print*,"total area (out of 1): ",area_check,ican
          print*,"layer: ",ican," of: ",this%n_lyr
          do icol = 1,this%n_col(ican)
             print*,this%scelg(ican,icol)%area,this%scelg(ican,icol)%pft
          end do
          print*,"TwoStreamMLPEMod.F90:CanopyPrep"
          stop
       end if
            
    end do do_can

    return
  end subroutine CanopyPrep

  ! ================================================================================================

  subroutine ZenithPrep(this,cosz)

    ! Pre-process things that change with the zenith angle
    ! i.e. the beam optical properties

    ! Important !!!!
    ! This should always be called after CanopyPrep() has been
    ! called.  This routine relies on the results of that routine
    ! notably the scattering coefficient "om".

    class(twostream_type) :: this
    integer               :: ib      ! band index, matches indexing of rad_params
    real(r8)              :: cosz    ! Cosine of the zenith angle

    integer :: ican  ! scattering element canopy layer index (top down)
    integer :: icol  ! scattering element column
    real(r8) :: asu  ! single scattering albedo
    real(r8) :: avmu ! Average inverse diffuse optical depth per unit leaf area
    real(r8) :: gdir
    real(r8) :: tmp0,tmp1,tmp2
    real(r8) :: betab_veg  ! beam backscatter for vegetation (no snow)
    real(r8) :: betab_om   ! multiplication of beam backscatter and reflectance
    real(r8) :: om_veg     ! scattering coefficient for vegetation (no snow)

    if( (cosz-1.0) > nearzero ) then
       print*,"The cosine of the zenith angle cannot exceed 1"
       print*,"cosz: ",cosz
       print*,"TwoStreamMLPEMod.F90:ZenithPrep"
       stop
    elseif(cosz<0._r8)then
       print*,"The cosine of the zenith angle should not be less than zero"
       print*,"It can be exactly zero, but not less than"
       print*,"cosz: ",cosz
       print*,"TwoStreamMLPEMod.F90:ZenithPrep"
       stop
    end if
       
    cosz = max(nearzero,cosz)

    do_ican: do ican = 1,this%n_lyr
       do_ical: do icol = 1,this%n_col(ican)

          associate(ft => this%scelg(ican,icol)%pft, &
               scelg => this%scelg(ican,icol))

            if(ft==0)then
               ! Simple provisions for a ghost element (air)
               scelg%Kb_leaf = k_air
               scelg%Kb = k_air
            else
               gdir = rad_params%phi1(ft) + rad_params%phi2(ft) * cosz

               !how much direct light penetrates a singleunit of lai?
               scelg%Kb_leaf = rad_params%clumping_index(ft) * gdir / cosz

               !print*,"Kb_leaf: ",scelg%Kb_leaf,gdir , cosz
               

               ! RGK: My sense is that snow should be adding optical depth
               !      but we don't have any precedent for that in the FATES
               !      code or old CLM. Re-view this.
               !!scelbp%Kb = this%frac_snow*k_snow + scelbp%Kb

               scelg%Kb = (scelg%lai*scelg%Kb_leaf + scelg%sai*1.0)/(scelg%lai+scelg%sai)

               ! Eq. 3.4 CLM50 Tech Man
               ! avmu is the average "av" inverse optical depth "mu" per unit leaf and stem area

               avmu = (1._r8 - rad_params%phi1(ft)/rad_params%phi2(ft) * &
                    log((rad_params%phi1(ft)+rad_params%phi2(ft))/rad_params%phi1(ft))) / rad_params%phi2(ft)

               ! Component terms for asu (single scatering albedo)
               tmp0 = gdir +  rad_params%phi2(ft) * cosz
               tmp1 =  rad_params%phi1(ft) * cosz
               tmp2 = 1._r8 - tmp1/tmp0 * log((tmp1+tmp0)/tmp1)

            end if

            do_ib: do ib = 1,this%n_bands

               associate( scelb => this%band(ib)%scelb(ican,icol) )

                 if(ft==0)then

                    ! Simple provisions for a ghost element (air)
                    scelb%betab = beta_air

                 else

                    ! betab - upscatter parameter for direct beam radiation, from G. Bonan
                    ! Eq. 3.16 CLM50 Tech Man
                    ! asu is the single scattering albedo per om_veg (material reflectance)

                    asu = 0.5_r8 * gdir / tmp0 * tmp2

                    betab_veg = (1._r8 + avmu*scelg%Kb) / (avmu*scelg%Kb) * asu

                    om_veg  =  (scelg%lai*rad_params%om_leaf(ib,ft) + &
                         scelg%sai*rad_params%om_stem(ib,ft))/(scelg%lai+scelg%sai)

                    ! Eq. 3.7 CLM50 Tech Man
                    betab_om = betab_veg*om_veg*(1._r8-this%frac_snow) + &
                         om_snow(ib)*betab_snow(ib)*this%frac_snow

                    scelb%betab = betab_om / scelb%om

                    if( .not.(scelb%betab==scelb%betab))then
                       print*,"Beam backscatter fraction is NaN"
                       print*, betab_om,scelb%om,om_veg,this%frac_snow,betab_veg,asu,avmu,scelg%Kb
                       stop
                    end if
                    

                 end if

               end associate
            end do do_ib
          end associate
       end do do_ical
    end do do_ican

    !this%band(ib)%albedo_grnd_beam = 1.e-36  ! Must fill this in

    return
  end subroutine ZenithPrep

  ! ================================================================================================

  subroutine GetNSCel(this)

    ! Simply return the total number
    ! of scattering elements from the
    ! multi-layer scattering element array

    class(twostream_type) :: this
    integer :: ican

    this%n_scel = 0
    do ican = 1,this%n_lyr
       this%n_scel = this%n_scel + this%n_col(ican)
    end do
    return
  end subroutine GetNSCel

  ! ===============================================================

  subroutine Solve(this, ib, &
       upper_boundary_type, & 
       Rbeam_atm, & 
       Rdiff_atm, &
       albedo_beam, & 
       albedo_diff, & 
       frac_abs_can_beam, &
       frac_abs_can_diff, &
       frac_beam_grnd_beam, &
       frac_diff_grnd_beam, &
       frac_diff_grnd_diff)

    ! Find the scattering coefficients for two-stream radiation in the canopy.

    ! Note that these scattering coefficients are separated for scattering
    ! generated by a beam radiation boundary condition, and a diffuse radiation
    ! boundary conditions. Thus, we need not provide the magnitude of the forcing
    ! for this step. If the user provides values of 1 for the Rbeam_atm and Rdiff_atm
    ! boundary condition. It is assumed this is a normalized solution.  If values
    ! other than 1 are passed, we assume that it is not a normalized solution,
    ! and we update the data structure values this%band(ib)%Rbeam_atm and
    ! this%band(ib)%Rdiff_atm.  In a normalized solution, we will leave this
    ! as unset.
    ! In ELM and CLM, the land-model requests an albedo and other
    ! normalized output from from this algorithm for the NEXT STEP. This is
    ! due to the atmospheric model needing an albedo to calculate the downwelling
    ! radiation on the next step. THus, the asynchronous nature of things.  That is
    ! why we allow a normalized solution here. When actual absorption or flux values are
    ! desired, the scattering coefficients that were determined during the normalized
    ! solution are still valid when the magnitude of the downwelling beam and diffuse
    ! radiation boundary conditions to the vegetation canopy are known.

    
    class(twostream_type) :: this
    integer   :: ib                 ! Band of interest, matches indexing of rad_params
    integer   :: upper_boundary_type ! Is this a normalized(1) or absolute(2) solution?
    
    real(r8)  :: Rbeam_atm          ! Intensity of beam radiation at top of canopy [W/m2 ground]
    real(r8)  :: Rdiff_atm          ! Intensity of diffuse radiation at top of canopy [W/m2 ground]
                                    ! 


    
    real(r8) :: albedo_beam    ! Mean albedo at canopy top generated from beam radiation [-]
    real(r8) :: albedo_diff    ! Mean albedo at canopy top generated from downwelling diffuse [-]
    real(r8) :: frac_abs_can_beam ! Fraction of incident beam radiation absorbed by the vegetation [-]
    real(r8) :: frac_abs_can_diff ! Fraction of incident diffuse radiation absorbed by the vegetation [-]
    real(r8) :: frac_beam_grnd_beam  ! fraction of beam radiation at ground resulting from of beam at canopy top [-]
    real(r8) :: frac_diff_grnd_beam  ! fraction of down diffuse radiation at ground resulting from beam at canopy top
    real(r8) :: frac_diff_grnd_diff  ! fraction of down diffuse radiation at ground resulting from down diffuse at canopy top [-]
    
    ! Two stream solution arrays
    ! Each of these are given generic names, because
    ! they are assemblages of many terms. But generally
    ! they fit the linear algebra formulation:
    !
    ! TAU(:) = OMEGA(:,:) * LAMBDA(:)
    !
    ! Where, we invert to solve for the coefficients LAMBDA

    real(r8),allocatable :: OMEGA(:,:)
    real(r8),allocatable :: TAU(:)
    real(r8),allocatable :: LAMBDA(:)

    integer :: isol  ! Solution index loop (beam, beam+diff)
    integer :: ican  ! Loop index for canopy layers
    integer :: ibot  ! layer index for top side of layer divide
    integer :: itop  ! layer index for bottom side of layer divide
    integer :: icol  ! Loop index for canopy columns
    integer :: jcol  ! Another loop index for canopy columns
    integer :: ilem  ! Index for scattering elements
    integer :: k1,k2 ! Indices for the lambda terms in the OMEGA and LAMBDA array
    integer :: qp    ! Equation position index

    integer :: ilem_off ! Offset, or total number of elements above layer of interest
    real(r8) :: b1,b2,a2,nu_sqrd,nu ! intermediate terms, see documentation
    real(r8) :: Rbeam_top           ! Mean beam radiation at top of layer      [W/m2]
    real(r8) :: Rbeam_bot           ! Mean beam radiation at bottom of layer   [W/m2]
    real(r8) :: vai                 ! Vegetation area index [m2 vegetation / m2 ground]
    real(r8) :: rb_abs              ! beam absorbed over an element    [W/m2 ground]
    real(r8) :: rd_abs              ! diffuse absorbed over an element [W/m2 ground]
    real(r8) :: rd_abs_leaf         ! diffuse absorbed over leaves (dummy)
    real(r8) :: rb_abs_leaf         ! beam absorbed by leaves (dummy)
    real(r8) :: r_abs_stem          ! total absorbed by stems (dummy)
    real(r8) :: r_abs_snow          ! total absorbed by snow (dummy)
    real(r8) :: leaf_sun_frac       ! sunlit fraction of leaves (dummy)
    real(r8) :: rel_err             ! radiation canopy balance conservation
                                    ! error, fraction of incident

    real(r8) :: beam_err,diff_err   ! error partitioned by beam and diffuse
    type(scelg_type),pointer :: scelgp   ! Pointer to the scelg data structure
    type(scelb_type),pointer :: scelbp   ! Pointer to the scelb data structure

    ! Parameters for solving via LAPACK DGELS()
    character(1),parameter :: trans = 'N'           ! Input matrix is not transposed
    integer, parameter :: workmax = 100             ! Maximum iterations to minimize work
    real(r8) :: work(workmax)                       ! Work array
    integer  :: lwork                               ! Dimension of work array
    integer :: info                                 ! Procedure diagnostic ouput

    ! Testing switch
    ! If true, then allow elements
    ! of different layers, but same row, to have priority
    ! flux into the other element, instead of a mix
    logical, parameter :: continuity_on = .true.    



    ! ------------------------------------------------------------------------------------
    ! Example system of equations for 2 parallel columns in each of two canopy
    ! layers.  Each line is one of the balanc equations. And the x's are
    ! the unknown coefficients used in those equations.  2 coefficients
    ! map to each element, and read left to right.
    ! EL1 is the element in top layer left column.
    ! EL2 is the element in the top layer, right column
    ! EL3 is the element in the bottom layer, left column
    ! EL4 is the element in the bottom layer, right column
    !
    !                                              EL1 EL2 EL3 EL4
    ! EQ: Idn balance with upper BC can1, col 1:   x x 
    ! EQ: Idn balance with upper BC can1, col 2:       x x
    ! EQ: Idn balance between upper & lower        x x x x x x
    ! EQ: Idn balance between upper & lower        x x x x     x x
    ! EQ: Iup balance between lower & upper        x x x x x x x x
    ! EQ: Iup balance between lower & upper        x x x x x x x x
    ! EQ: Iup/Idn balance with ground, 1st col:            x x
    ! EQ: Iup/Idn Balance with ground, 2nd lower col:          x x  
    !
    !     Note: The Iup balance between layers requires ALL
    !     terms, because light comes out of both
    !     upper canopy elements and reflects off soil
    !     AND, light upwells from both lower elements.
    !
    ! --------------------------------------------------------------------------

    ! --------------------------------------------------------------------------
    ! Beam Scattering
    ! First do the direct beam stuff.  It is a trivial solution
    ! and is required as a boundary condition to the diffuse solver
    ! All parallel layers recieve downwelling form the
    ! atmosphere.
    ! Rbeam0 is the upper boundary condition provided by data or another
    ! model.
    ! Rbeam() is the incident beam radiation at the top of each layer
    ! upper canopy.
    ! --------------------------------------------------------------------------

    if((Rbeam_atm+Rdiff_atm)<nearzero)then
       print*,"No radiation"
       print*,"Two stream should not had been called"
       print*,Rbeam_atm,Rdiff_atm
       stop
    end if
    
    Rbeam_top = 1.0_r8
    do ican = 1,this%n_lyr
       Rbeam_bot = 0._r8
       do icol = 1,this%n_col(ican)
          scelgp => this%scelg(ican,icol)
          scelbp => this%band(ib)%scelb(ican,icol)
          scelbp%Rbeam0 = Rbeam_top
          Rbeam_bot = Rbeam_bot + &
               Rbeam_top*scelgp%area*exp(-scelgp%Kb*(scelgp%lai+scelgp%sai))
       end do
       Rbeam_top = Rbeam_bot
    end do

    ! Calculate element-level intermediate terms to the solve
    ! These are dependent on leaf level scattering and beam scattering
    ! These values will be used to populate the matrix solve
    ! =====================================================================

    do ican = 1,this%n_lyr
       do icol = 1,this%n_col(ican)

          scelgp => this%scelg(ican,icol)
          scelbp => this%band(ib)%scelb(ican,icol)

          a2 = scelgp%Kd*scelgp%Kd*(scelbp%om-1._r8)*(scelbp%om-1._r8-2._r8*scelbp%om*scelbp%betad)

          if(a2<0._r8) then
             print*,'a^2 is less than zero'
             stop
          end if

          scelbp%a  = sqrt(a2)

          b1 = (scelgp%Kd*(1._r8-scelbp%om)*(1._r8-2._r8*scelbp%betab)+scelgp%Kb) * &
               scelbp%om*scelgp%Kb*scelbp%Rbeam0
          b2 = (scelgp%Kd*(scelbp%om-1._r8-2._r8*scelbp%om*scelbp%betad) - &
               (1._r8-2._r8*scelbp%betab)*scelgp%Kb) * &
               scelbp%om*scelgp%Kb*scelbp%Rbeam0

          if(use_derivation1) then

             nu_sqrd = (1._r8-scelbp%om+2._r8*scelbp%om*scelbp%betad)/(1._r8-scelbp%om)

             if(nu_sqrd<0._r8)then
                print*,'nu_sqrd is less than zero'
                stop
             end if

             ! B_1 up term from documentation:
             scelbp%B1u  = 0.5_r8*(1._r8+sqrt(nu_sqrd))

             ! B_2 up term from documentation
             scelbp%B2u = 0.5_r8*(1._r8-sqrt(nu_sqrd))

             ! B_1 down term from documentation:
             scelbp%B1d  = -0.5_r8*(1._r8-sqrt(nu_sqrd))

             ! B_2 down term from documentation
             scelbp%B2d = -0.5_r8*(1._r8+sqrt(nu_sqrd))

             ! A_2 term from documentation
             scelbp%Ad    = -0.5_r8*(b2-b1)/(scelbp%a*scelbp%a-scelgp%Kb*scelgp%Kb)   ! aka half b2 minus b1

             ! A_1 term from documentation
             scelbp%Au    = -0.5_r8*(b2+b1)/(scelbp%a*scelbp%a-scelgp%Kb*scelgp%Kb)   ! aka half b1 plus b2

          else

             nu_sqrd = (scelbp%om-1._r8)/(scelbp%om - 1._r8-2._r8*scelbp%om*scelbp%betad)

             nu = (scelgp%Kd*(scelbp%om-1._r8))/scelbp%a

             b1 = -b1

             ! B 1 up term from documentation
             !scelbp%B1u  = 0.5_r8*(1._r8-nu)
             scelbp%B1u  = 0.5_r8*(1._r8-sqrt(nu_sqrd))

             ! B_2 term from documentation
             !scelbp%B2u = 0.5_r8*(1._r8+nu)
             scelbp%B2u  = 0.5_r8*(1._r8+sqrt(nu_sqrd))

             ! B 1 up term from documentation
             !scelbp%B1d  = 0.5_r8*(1._r8+nu)
             scelbp%B1d  = 0.5_r8*(1._r8+sqrt(nu_sqrd))

             ! B_2 term from documentation
             !scelbp%B2d = 0.5_r8*(1._r8-nu)
             scelbp%B2d  = 0.5_r8*(1._r8-sqrt(nu_sqrd))

             ! A_2 term from documentation
             scelbp%Ad    = -0.5_r8*(b2+b1)/(scelbp%a*scelbp%a-scelgp%Kb*scelgp%Kb)   ! aka half b2 minus b1

             ! A_1 term from documentation
             scelbp%Au    = -0.5_r8*(b2-b1)/(scelbp%a*scelbp%a-scelgp%Kb*scelgp%Kb)   ! aka half b1 plus b2

             
          end if
       end do
    end do

    ! =====================================================================
    ! Set up the linear systems solver
    !
    ! [TAU] = [OMEGA]*[LAMBDA]
    ! OMEGA(n_equations,n_coefficients)
    ! TAU(n_equations)
    ! LAMBDA (n_coefficients) (the solution)
    !
    ! Indexing Variables
    ! ilem : element position
    ! k1 : coefficient 1 position
    ! k2 : coefficient 2 position
    ! qp : equation position, this continues to increment
    ! =====================================================================

    ! TO-DO: MAKE THIS SCRATCH SPACE AT THE SITE LEVEL?
    allocate(OMEGA(2*this%n_scel,2*this%n_scel))
    allocate(TAU(2*this%n_scel))
    allocate(LAMBDA(2*this%n_scel))

    ! We come up with two solutions:
    ! First: we run with now diffuse downwelling
    ! radiation, this allows us to calculate
    ! the canopy top albedo for beam radiation only
    ! which is useful for coupling with the atmosphere
    ! Second: we run with bot simultaneously, and
    ! use that solution to understand everything
    ! else, including the absorbed radiation

    do_isol: do isol = 1,2

       
       ! This is temporary (these need to be set
       ! because this routine makes a call to get normalized
       ! absorbtions to get total noramalized canopy absorbtion)
       ! We will set it back to unknown following that call
       
       if(isol==1)then
          this%band(ib)%Rbeam_atm = 1.0_r8
          this%band(ib)%Rdiff_atm = 0.0_r8
       else
          this%band(ib)%Rbeam_atm = 0.0_r8
          this%band(ib)%Rdiff_atm = 1.0_r8
       end if
       
       OMEGA(:,:) = 0._r8
       TAU(:)     = 0._r8
       
       ! --------------------------------------------------------------------
       ! I. Flux equations with the atmospheric boundary
       ! These balance with all elements in the upper
       ! canopy, only.  The upper canopy is layer 1.
       ! --------------------------------------------------------------------

       qp = 0    ! e"Q"uation "P"osition
       do icol = 1,this%n_col(1)
          scelgp => this%scelg(1,icol)
          scelbp => this%band(ib)%scelb(1,icol)
          ilem = icol
          qp   = qp   + 1
          k1 = 2*(ilem-1)+1
          k2 = k1+1
          TAU(qp)      =  this%band(ib)%Rdiff_atm - this%band(ib)%Rbeam_atm*scelbp%Ad
          OMEGA(qp,k1) =  scelbp%B1d
          OMEGA(qp,k2) =  scelbp%B2d
       end do


       if_understory: if(this%n_lyr>1) then


          ! -------------------------------------------------------------------
          ! II. Flux equations between canopy layers, DOWNWELLING
          ! We only perform flux balancing between layers
          ! if we have any understory, this is true if ican>1
          ! -------------------------------------------------------------------
          ! Refer to Equation X in technical document
          ! ------------------------------------------------------------

          ! This is the index offset for the layer above the
          ! current layer of interest. We start by evaluating
          ! Layer 2, so the offset refers to layer 1, and a
          ! value of 0

          ilem_off = 0
          do_dn_ican: do ican = 2,this%n_lyr

             itop = ican-1  ! Top layer of the balance
             ibot = ican    ! Bottom layer of the balance

             ! Downwelling, includes all members from top for
             ! each independant member below

             do jcol = 1,this%n_col(ibot)

                qp = qp + 1
                ilem = ilem_off + this%n_col(itop) + jcol
                k1 = 2*(ilem-1)+1
                k2 = k1 + 1

                ! Include the self terms for the current element
                ! This term is at v=0

                TAU(qp) = this%band(ib)%Rbeam_atm*this%band(ib)%scelb(ibot,jcol)%Ad
                OMEGA(qp,k1) = OMEGA(qp,k1) - this%band(ib)%scelb(ibot,jcol)%B1d
                OMEGA(qp,k2) = OMEGA(qp,k2) - this%band(ib)%scelb(ibot,jcol)%B2d

                ! We need to include the terms from
                ! all elements above the current element of interest
                ! (this can be moved out of jcol loop for efficiency)
                do icol = 1,this%n_col(itop)

                   ilem = ilem_off + icol
                   k1 = 2*(ilem-1)+1
                   k2 = k1 + 1

                   scelgp => this%scelg(itop,icol)
                   scelbp => this%band(ib)%scelb(itop,icol)

                   vai = scelgp%lai + scelgp%sai

                   TAU(qp) = TAU(qp) - scelgp%area * this%band(ib)%Rbeam_atm*scelbp%Ad *exp(-scelgp%Kb*vai)
                   OMEGA(qp,k1) = OMEGA(qp,k1) + scelgp%area * scelbp%B1d*exp(scelbp%a*vai)
                   OMEGA(qp,k2) = OMEGA(qp,k2) + scelgp%area * scelbp%B2d*exp(-scelbp%a*vai)

                end do

             end do

             ilem_off = ilem_off + this%n_col(itop)

          end do do_dn_ican


          ! -------------------------------------------------------------------
          ! III. Flux equations between canopy layers, UPWELLING
          ! -------------------------------------------------------------------
          ! Refer to equation X in the technical documentation.
          ! Note the upwelling balance is performed on the upper layer,
          ! one equation for each element in the upper layer.
          ! Note that since we use "ghost elements" or air elements
          ! we don't have to factor in reflections from exposed ground.
          ! These effects will be mediated through the ghost elements
          ! -------------------------------------------------------------------

          ilem_off = 0

          do_up_ican: do ican = 2,this%n_lyr

             itop = ican-1
             ibot = ican

             do icol = 1,this%n_col(itop)

                qp = qp + 1

                ! Self terms (ie the upwelling evaluated at the bottom edge of each top element)
                ilem = ilem_off + icol
                k1   = 2*(ilem-1)+1
                k2   = k1 + 1
                scelgp => this%scelg(itop,icol)
                scelbp => this%band(ib)%scelb(itop,icol)

                vai = scelgp%lai + scelgp%sai
                TAU(qp) = this%band(ib)%Rbeam_atm*scelbp%Au*exp(-scelgp%Kb*vai)
                OMEGA(qp,k1) = OMEGA(qp,k1) - scelbp%B1u*exp(scelbp%a*vai)
                OMEGA(qp,k2) = OMEGA(qp,k2) - scelbp%B2u*exp(-scelbp%a*vai)

                ! Terms for mean diffuse exiting lower elements (move out of this loop for efficiency)
                do jcol = 1,this%n_col(ibot)
                   ilem = ilem_off + this%n_col(itop) + jcol
                   k1 = 2*(ilem-1)+1
                   k2 = k1 + 1
                   scelgp => this%scelg(ibot,jcol)
                   scelbp => this%band(ib)%scelb(ibot,jcol)

                   TAU(qp) = TAU(qp) - this%band(ib)%Rbeam_atm*scelgp%area*scelbp%Au
                   OMEGA(qp,k1) = OMEGA(qp,k1) + scelgp%area*scelbp%B1u
                   OMEGA(qp,k2) = OMEGA(qp,k2) + scelgp%area*scelbp%B2u
                end do

             end do

             ilem_off = ilem_off + this%n_col(itop)
          end do do_up_ican


       end if if_understory


       ! Flux balance equations between the understory elements, and
       ! the ground below them
       ilem_off = 0
       do ican=1,this%n_lyr-1
          ilem_off = ilem_off + this%n_col(ican)
       end do

       do jcol = 1,this%n_col(this%n_lyr)

          ilem = ilem_off + jcol
          qp = qp + 1
          k1 = 2*(ilem-1)+1
          k2 = k1 + 1

          scelgp => this%scelg(this%n_lyr,jcol)
          scelbp => this%band(ib)%scelb(this%n_lyr,jcol)

          vai = scelgp%lai + scelgp%sai

          TAU(qp) = this%band(ib)%Rbeam_atm*(scelbp%Au*exp(-scelgp%Kb*vai)  &
               - this%band(ib)%albedo_grnd_diff*scelbp%Ad*exp(-scelgp%Kb*vai) &
               - this%band(ib)%albedo_grnd_beam*scelbp%Rbeam0*exp(-scelgp%Kb*vai))

          OMEGA(qp,k1) = OMEGA(qp,k1) - scelbp%B1u*exp(scelbp%a*vai)
          OMEGA(qp,k2) = OMEGA(qp,k2) - scelbp%B2u*exp(-scelbp%a*vai)

          OMEGA(qp,k1) = OMEGA(qp,k1) + this%band(ib)%albedo_grnd_diff*scelbp%B1d*exp(scelbp%a*vai)
          OMEGA(qp,k2) = OMEGA(qp,k2) + this%band(ib)%albedo_grnd_diff*scelbp%B2d*exp(-scelbp%a*vai)

       end do

       LAMBDA = TAU
       ! Solution borrowed from Greg Lemieux's usage during FATES canopy trimming:
       ! Compute the optimum size of the work array

       lwork = -1 ! Ask dgels to compute optimal number of entries for work
       call dgels(trans, this%n_scel*2, this%n_scel*2, 1, OMEGA, this%n_scel*2, LAMBDA, this%n_scel*2, work, lwork, info)
       lwork = int(work(1)) ! Pick the optimum.  TBD, can work(1) come back with greater than work size?

       ! Compute the minimum of 2-norm of of the least squares fit to solve for X
       ! Note that dgels returns the solution by overwriting the LAMBDA array.
       ! The result has the form: X = [b; m]
       call dgels(trans, this%n_scel*2, this%n_scel*2, 1, OMEGA, this%n_scel*2, LAMBDA, this%n_scel*2, work, lwork, info)

       ! Save the solution terms

       ilem_off = 0
       if(isol==1)then  !Beam
          do ican = 1,this%n_lyr
             do icol = 1,this%n_col(ican)
                ilem = ilem_off + icol
                k1 = 2*(ilem-1)+1
                k2 = k1 + 1
                scelgp => this%scelg(ican,icol)
                scelbp => this%band(ib)%scelb(ican,icol)
                scelbp%lambda1_beam = LAMBDA(k1)
                scelbp%lambda2_beam = LAMBDA(k2)
             end do
             ilem_off = ilem_off + this%n_col(ican)
          end do
       else
          do ican = 1,this%n_lyr
             do icol = 1,this%n_col(ican)
                ilem = ilem_off + icol
                k1 = 2*(ilem-1)+1
                k2 = k1 + 1
                scelgp => this%scelg(ican,icol)
                scelbp => this%band(ib)%scelb(ican,icol)
                scelbp%lambda1_diff = LAMBDA(k1)
                scelbp%lambda2_diff = LAMBDA(k2)
             end do
             ilem_off = ilem_off + this%n_col(ican)
          end do
       end if
          
       ! Process the total canopy absorbed radiation in the
       ! two types of radiation, as well as the downwelling
       ! flux at the ground interface
       ! --------------------------------------------------------------------------------
       
       if_beam: if(isol==1)then

          ican = 1
          albedo_beam = 0._r8
          do icol = 1,this%n_col(ican)
             scelgp => this%scelg(ican,icol)
             scelbp => this%band(ib)%scelb(ican,icol)
             albedo_beam = albedo_beam + &
                  scelgp%area * this%GetRdUp(ican,icol,ib,0._r8)
          end do

          frac_diff_grnd_beam = 0._r8
          frac_beam_grnd_beam = 0._r8
          ican = this%n_lyr
          do icol = 1,this%n_col(ican)
             scelgp => this%scelg(ican,icol)
             scelbp => this%band(ib)%scelb(ican,icol)
             frac_diff_grnd_beam = frac_diff_grnd_beam + &
                  scelgp%area*this%GetRdDn(ican,icol,ib,scelgp%lai+scelgp%sai)
             frac_beam_grnd_beam = frac_beam_grnd_beam + &
                  scelgp%area*scelbp%Rbeam0*exp(-scelgp%Kb*(scelgp%lai+scelgp%sai))
          end do

          frac_abs_can_beam = 0._r8
          do ican = 1,this%n_lyr
             do icol = 1,this%n_col(ican)
                scelgp => this%scelg(ican,icol)
                scelbp => this%band(ib)%scelb(ican,icol)
                call this%GetAbsRad(ican,icol,ib, 0._r8,scelgp%lai+scelgp%sai, &
                     rb_abs,rd_abs,rd_abs_leaf,rb_abs_leaf,r_abs_stem,r_abs_snow,leaf_sun_frac)
                frac_abs_can_beam = frac_abs_can_beam + scelgp%area*(rb_abs+rd_abs)
             end do
          end do
          
       else  ! Diffuse
             
          albedo_diff = 0._r8
          do icol = 1,this%n_col(1)
             scelgp => this%scelg(1,icol)
             scelbp => this%band(ib)%scelb(1,icol)
             albedo_diff = albedo_diff + &
                  scelgp%area * this%GetRdUp(1,icol,ib,0._r8)
          end do

          frac_abs_can_diff = 0._r8
          
          do ican = 1,this%n_lyr
             do icol = 1,this%n_col(ican)
                scelgp => this%scelg(ican,icol)
                scelbp => this%band(ib)%scelb(ican,icol)
                call this%GetAbsRad(ican,icol,ib,0._r8,scelgp%lai+scelgp%sai, &
                     rb_abs,rd_abs,rd_abs_leaf,rb_abs_leaf,r_abs_stem,r_abs_snow,leaf_sun_frac)
                frac_abs_can_diff = frac_abs_can_diff + scelgp%area*rd_abs
             end do
          end do
          
          frac_diff_grnd_diff = 0._r8
          ican = this%n_lyr
          do icol = 1,this%n_col(ican)
             scelgp => this%scelg(ican,icol)
             scelbp => this%band(ib)%scelb(ican,icol)
             frac_diff_grnd_diff = frac_diff_grnd_diff + &
                  scelgp%area*this%GetRdDn(ican,icol,ib,scelgp%lai+scelgp%sai)
          end do
          
       end if if_beam
       
    end do do_isol

    deallocate(OMEGA)
    deallocate(TAU)
    deallocate(LAMBDA)

    
    ! Check the error balance
    ! ---------------------------------------------------------------------------------------------

    ! Source = upwelling + canopy absorbed + ground absorbed
    
    rel_err = ((Rbeam_atm + Rdiff_atm) - &
               (albedo_diff  + albedo_beam ) - & 
               (frac_abs_can_diff   + frac_abs_can_beam) - & 
               ((frac_diff_grnd_diff+frac_diff_grnd_beam)*(1._r8-this%band(ib)%albedo_grnd_diff)) - &
               (frac_beam_grnd_beam*(1._r8-this%band(ib)%albedo_grnd_beam)) ) / (Rbeam_atm + Rdiff_atm)

    beam_err = Rbeam_atm - (albedo_beam + frac_abs_can_beam + &
         frac_diff_grnd_beam*(1._r8-this%band(ib)%albedo_grnd_diff) + &
         frac_beam_grnd_beam*(1._r8-this%band(ib)%albedo_grnd_beam))

    diff_err = Rdiff_atm - (albedo_diff + frac_abs_can_diff + &
         frac_diff_grnd_diff*(1._r8-this%band(ib)%albedo_grnd_diff))
    
    if( abs(rel_err) > rel_err_thresh ) then
       print*,"Total canopy flux balance not closing in TwoStrteamMLPEMod:Solve"
       print*,"Relative Error, delta/(Rbeam_atm+Rdiff_atm) :",rel_err
       print*,"Max Error: ",rel_err_thresh
       print*,"ib: ",ib
       print*, beam_err,diff_err
       print*, frac_diff_grnd_beam*(1._r8-this%band(ib)%albedo_grnd_diff) + &
            frac_beam_grnd_beam*(1._r8-this%band(ib)%albedo_grnd_beam)
       print*, frac_diff_grnd_diff*(1._r8-this%band(ib)%albedo_grnd_diff)
       print*, albedo_beam,albedo_diff
       print*, frac_abs_can_beam,frac_abs_can_diff
       print*, frac_diff_grnd_beam,frac_beam_grnd_beam,frac_diff_grnd_diff
       print*, "scattering coeff: ",(2*rad_params%om_leaf(ib,1)+0.5*rad_params%om_stem(ib,1))/2.5
       print*, "Breakdown:",this%n_lyr
       do ican = 1,this%n_lyr
          do icol = 1,this%n_col(ican)
             scelgp => this%scelg(ican,icol)
             scelbp => this%band(ib)%scelb(ican,icol)
             print*,"    ",ican,icol
             print*,"    ",scelgp%lai+scelgp%sai,scelgp%pft,scelgp%area
             print*,"    ",scelbp%om,scelgp%Kb,scelgp%Kd,scelbp%betab,scelbp%betad
             print*,"    ",scelbp%om*(1.0-scelbp%betad)
             print*,"    ",scelbp%lambda1_beam,scelbp%lambda2_beam
             print*,"    ",scelbp%lambda1_diff,scelbp%lambda2_diff
          end do
       end do
       stop
    end if

    
    ! Set the boundary conditions back to unknown for a normalized solution
    ! This prevents us from calling the absorption and flux query routines incorrectly.
    ! For non-normalized, set it to the actual input boundary conditions
    
    if(upper_boundary_type.eq.normalized_upper_boundary) then
       this%band(ib)%Rbeam_atm = unset_r8
       this%band(ib)%Rdiff_atm = unset_r8
    else
       this%band(ib)%Rbeam_atm = Rbeam_atm
       this%band(ib)%Rdiff_atm = Rdiff_atm
    end if

    
    return
  end subroutine Solve


end Module TwoStreamMLPEMod
